name: "Update Go Dependencies"
description: "Update multiple Go dependencies and generate a changelog."
inputs:
  repos:
    description: "A comma or newline separated list of repositories to update, each with a specific version (e.g., 'github.com/anchore/stereoscope@main,github.com/anchore/syft@latest')"
    required: true

outputs:
  changelog:
    description: "The changelog detailing the version updates for each repository."
    value: ${{ steps.update-deps.outputs.changelog }}
  draft:
    description: "Whether the changelog should be marked as a draft."
    value: ${{ steps.update-deps.outputs.draft }}

runs:
  using: "composite"
  steps:
    - name: Update dependencies and generate changelog
      id: update-deps
      shell: python
      run: |
        import subprocess
        import re
        import os

        def run(cmd, **kwargs):
          opts = {
            "shell": True,
            "text": True,
            "check": True,
          }
          opts.update(kwargs)

          print(cmd)
          if "capture_output" not in opts or not opts["capture_output"]:
            opts.update({
              "stdout": None,  # Stream to the terminal (default behavior)
              "stderr": None
            })
            return subprocess.run(cmd, **opts)

          opts["capture_output"] = True

          result = subprocess.run(cmd, **opts)

          if result.stdout:
            print(result.stdout)
          if result.stderr:
            print(result.stderr)
          print("\n")

          return result

        # Parse the input repositories
        repos_input = re.split("[\n|,]", """${{ inputs.repos }}""".strip())
        changelog_entries = []

        draft = "false"
        has_downgrade = False
        for repo_info in repos_input:
          repo, version = repo_info.strip().split('@')
          print(f"Updating {repo} to {version}")

          # get original version (fails if not in go.mod file)
          original_version = run(f"go list -m -f '{{{{.Version}}}}' {repo}", capture_output=True).stdout.strip()

          # perform the `go get` command to update the dependency
          log = run(f"go get {repo}@{version}", shell=True, text=True, capture_output=True).stderr.strip()

          # check for downgrade or update
          if f"downgraded {repo}" in log:
            action = "downgrade"
            draft = "always-true"
            has_downgrade = True
          else:
            action = "update"

          print(f"Action: {action}")

          # get the resolved version after go get
          resolved_version = run(f"go list -m -f '{{{{.Version}}}}' {repo}", capture_output=True).stdout.strip()

          if resolved_version == "unknown" or "-" in resolved_version:
            draft = "always-true"

          # tidy up the go.mod file
          run("go mod tidy", capture_output=False)

          # create the changelog entry
          repo_name = repo.split('/')[-1].capitalize()
          changelog_entry = f" - **{repo_name}**: `{original_version}` âž” `{resolved_version}` (requested `{version}`)"
          if action == "downgrade":
            changelog_entry += " ðŸ”´ ***Downgrade***"
          changelog_entries.append(changelog_entry)

        # construct the full changelog body
        pr_body = ""
        if has_downgrade:
          pr_body = "> [!WARNING]\n> Some dependencies were downgraded, please review if this was intentional\n\n"
        pr_body += "## Dependencies changed\n"
        pr_body += "\n".join(changelog_entries)

        print(pr_body)

        # write the changelog output
        with open(os.getenv("GITHUB_OUTPUT"), "a") as output_file:
          output_file.write("changelog<<EOF\n")
          output_file.write(f"{pr_body}\n")
          output_file.write("EOF\n")
          output_file.write(f"draft={draft}\n")

        with open(os.getenv("GITHUB_STEP_SUMMARY"), "a") as output_file:
          output_file.write(f"{pr_body}\n")
