# runs-on.com runner configuration

runners:
  # GENERAL PURPOSE RUNNERS ##########################################################################################

  # small: fast, cost-effective runners for lightweight jobs
  # - orchestration (selecting providers, aggregating results)
  # - static analysis (linting, type checking)
  # - unit tests (Python test suites)
  # disk: 40GB (default)
  small:
    cpu: 2
    ram: [4, 8]
    family:
      - "c7*" # compute-optimized gen 7 (* = all sizes)
      - "m7*" # general-purpose gen 7
      - "c6i*" # compute-optimized gen 6 Intel
      - "m6i*" # general-purpose gen 6 Intel
      - "c6a*" # compute-optimized gen 6 AMD
      - "m6a*" # general-purpose gen 6 AMD
      - "c5*" # compute-optimized gen 5
      - "m5*" # general-purpose gen 5
    spot: price-capacity-optimized
    extras: s3-cache

  # quality-gate: beefy runners for vulnerability data processing
  # - downloading and processing large vulnerability databases
  # - running provider validation against real-world data sets
  # - 2 CPUs sufficient (Python I/O-bound workloads)
  # disk: 40GB (default)
  quality-gate:
    cpu: 2
    ram: [16, 32]
    disk: large # 80gb EBS volume, see https://runs-on.com/configuration/job-labels/#disk
    family:
      - "r7*" # memory-optimized gen 7 (* = all sizes)
      - "r6i*" # memory-optimized gen 6 Intel
      - "r6a*" # memory-optimized gen 6 AMD
      - "m7*" # general-purpose gen 7
      - "m6i*" # general-purpose gen 6 Intel
      - "m6a*" # general-purpose gen 6 AMD
      - "r5*" # memory-optimized gen 5
      - "m5*" # general-purpose gen 5
    spot: false # spot is not a good idea for quality-gate jobs, as they take a while to run
    extras: s3-cache

  # release: reliable on-demand runners for production deployments
  # - tagging releases
  # - publishing to PyPI
  # - promoting Docker images to production registries
  # - creating GitHub releases
  # spot: false for 100% reliability (no interruptions during releases)
  # disk: 40GB (default)
  release:
    cpu: 2
    ram: [4, 8]
    family:
      - "c7*" # compute-optimized gen 7 (* = all sizes)
      - "m7*" # general-purpose gen 7
      - "c6i*" # compute-optimized gen 6 Intel
      - "m6i*" # general-purpose gen 6 Intel
      - "c6a*" # compute-optimized gen 6 AMD
      - "m6a*" # general-purpose gen 6 AMD
      - "c5*" # compute-optimized gen 5
      - "m5*" # general-purpose gen 5
    spot: false # never use spot instances for release jobs
    extras: ["s3-cache", "ephemeral-registry"]

  # large: beefy runners for building a DB and syncing large data sets
  # - downloading and processing large vulnerability data sets
  # spot: false for 100% reliability (no interruptions for longer running / production related jobs)
  # disk: 40GB (default)
  large:
    cpu: 4
    ram: [32] # grype-db was having memory issues for 16 GB runners
    disk: large # 80gb EBS volume, see https://runs-on.com/configuration/job-labels/#disk
    family:
      - "r7*" # memory-optimized gen 7 (* = all sizes)
      - "r6i*" # memory-optimized gen 6 Intel
      - "r6a*" # memory-optimized gen 6 AMD
      - "m7*" # general-purpose gen 7
      - "m6i*" # general-purpose gen 6 Intel
      - "m6a*" # general-purpose gen 6 AMD
      - "r5*" # memory-optimized gen 5
      - "m5*" # general-purpose gen 5
    spot: false # these tasks might run for longer, thus we want to avoid interruptions
    extras: s3-cache

  # ARM RUNNERS ####################################################################################################

  # tiny: ultra cost-effective ARM runners for trivial workloads
  # - dependency updates (Dependabot)
  # - label management
  # - quick validation checks
  # - workflow orchestration/triggers
  # ARM burstable instances ~50% cheaper than x64
  # disk: 40GB (default)
  tiny:
    cpu: 2
    ram: [4]
    family:
      - "t4g*" # ARM burstable gen 4 (primary)
      - "t3*" # x64 burstable gen 3 (fallback)
      - "t3a*" # x64 burstable gen 3 AMD (fallback)
    spot: price-capacity-optimized
    extras: s3-cache

  # small-arm: ARM equivalent of 'small' runner
  # - unit tests
  # - static analysis
  # - linting
  # ARM instances ~3-10% cheaper than x64, better for sustained workloads than tiny
  # disk: 40GB (default)
  small-arm:
    cpu: 2
    ram: [4, 8]
    family:
      - "c7g*" # compute-optimized ARM gen 7
      - "m7g*" # general-purpose ARM gen 7
      - "c6g*" # compute-optimized ARM gen 6
      - "m6g*" # general-purpose ARM gen 6
      - "c6gn*" # network-optimized ARM gen 6
      - "t4g*" # burstable ARM gen 4 (fallback)
    spot: price-capacity-optimized
    extras: s3-cache

  # large-arm: ARM equivalent of 'large' runner
  # - DB building (if ARM compatible)
  # - large data processing
  # ARM instances ~9-15% cheaper than x64
  # spot: false for reliability
  # disk: 80GB
  large-arm:
    cpu: 4
    ram: [32]
    disk: large
    family:
      - "r7g*" # memory-optimized ARM gen 7
      - "r6g*" # memory-optimized ARM gen 6
      - "m7g*" # general-purpose ARM gen 7
      - "m6g*" # general-purpose ARM gen 6
      - "c7g*" # compute-optimized ARM gen 7 (fallback)
      - "c6g*" # compute-optimized ARM gen 6 (fallback)
    spot: false # these tasks might run for longer, thus we want to avoid interruptions
    extras: s3-cache
